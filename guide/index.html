<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · SixDOF.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SixDOF.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Guide</a><ul class="internal"></ul></li><li><a class="toctext" href="../theory/">Theory</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Guide</a></li></ul><a class="edit-page" href="https://github.com/byuflowlab/SixDOF.jl/blob/master/docs/src/guide.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Guide-1" href="#Guide-1">Guide</a></h1><p>First, we import the module.</p><pre><code class="language-julia">using SixDOF</code></pre><p>There are several structs we need to define.  The inputs used in this example correspond to the Zagi flying wing in Appendix E of Small Unmanned Aircraft: Theory and Practice by Beard and McLain.  We specify the mass properties:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.MassProp" href="#SixDOF.MassProp"><code>SixDOF.MassProp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MassProp(m, Ixx, Iyy, Izz, Ixz, Ixy, Iyz)</code></pre><p>Mass and moments of inertia in the body frame. Ixx = int(y^2 + z^2, dm) Ixz = int(xz, dm)</p><p>Most aircraft are symmetric about y and so there is a convenience method  to specify only the nonzero components. MassProp(m, Ixx, Iyy, Izz, Ixz)</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL49-L59">source</a></section><p>For this example:</p><pre><code class="language-julia">m = 1.56
Ixx = 0.1147
Iyy = 0.0576
Izz = 0.1712
Ixz = 0.0015
mp = MassProp(m, Ixx, Iyy, Izz, Ixz)</code></pre><p>Next, we specify reference areas and lengths:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.Reference" href="#SixDOF.Reference"><code>SixDOF.Reference</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Reference(S, b, c)</code></pre><p>The reference area, span, and chord used in the aerodynamic computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL74-L78">source</a></section><pre><code class="language-julia">Sref = 0.2589
bref = 1.4224
cref = 0.3302
ref = Reference(Sref, bref, cref)</code></pre><p>Control inputs need to be as follows:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.Control" href="#SixDOF.Control"><code>SixDOF.Control</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Control(de, dr, da, df, throttle)</code></pre><p>Define the control settings: delta elevator, delta rudder, delta aileron,  delta flaps, and throttle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL35-L40">source</a></section><p>In this example, we don&#39;t use any control deflections.  Just throttle, at 80%.</p><pre><code class="language-julia">control = Control(0.0, 0.0, 0.0, 0.0, 0.8)</code></pre><p>Next, we define the atmospheric model.  <code>AtmosphereModel</code> is an abstract type that must define the following three methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.wind-Tuple{AtmosphereModel,Any}" href="#SixDOF.wind-Tuple{AtmosphereModel,Any}"><code>SixDOF.wind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wind(model::AtmosphereModel, state)</code></pre><p>Compute wind velocities.</p><p><strong>Returns</strong></p><ul><li>Wi: wind velocities in inertial frame</li><li>Wb: gust velocities in body frame (just a convenience to allow some velocities in body frame)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL92-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.properties-Tuple{AtmosphereModel,Any}" href="#SixDOF.properties-Tuple{AtmosphereModel,Any}"><code>SixDOF.properties</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">properties(model::AtmosphereModel, state)</code></pre><p>Compute atmospheric density and the speed of sound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL108-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.gravity" href="#SixDOF.gravity"><code>SixDOF.gravity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gravity(model::AtmosphereModel, state)</code></pre><p>Compute the local acceleration of gravity.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL120-L124">source</a></section><p>There is a default implementation in the module, which is the simplest possible model: one with constant properties:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.ConstantAtmosphere" href="#SixDOF.ConstantAtmosphere"><code>SixDOF.ConstantAtmosphere</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConstantAtmosphere(Wi, Wb, rho, asound, g)</code></pre><p>Constant atmospheric properties.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL484-L488">source</a></section><p>We use that in this example:</p><pre><code class="language-julia">Wi = [0.0, 0.0, 0.0]
Wb = [0.0, 0.0, 0.0]
rho = 1.2682
asound = 300.0
g = 9.81
atm = ConstantAtmosphere(Wi, Wb, rho, asound, g)</code></pre><p>Finally, we now need to define the forces and moments.  We provide three abstract types for three types of forces: aerodynamics, propulsion, and gravity.  In principle you could use these methods to define forces/moments for any application, but for aircraft this is a convenient separation.</p><p>All three forces take in all the same inputs, which include everything discussed so far and the state.  The state is an internally used struct that contains the state of the aircraft (or other object).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.State" href="#SixDOF.State"><code>SixDOF.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">State(x, y, z, phi, theta, psi, u, v, w, p, q, r)</code></pre><p>State of the aircraft: positions in inertial frame, euler angles, velocities in body frame, angular velocities in body frame.</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL14-L19">source</a></section><p>The <code>AeroModel</code> abstract type must define the following function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.aeroforces-Tuple{AeroModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}" href="#SixDOF.aeroforces-Tuple{AeroModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}"><code>SixDOF.aeroforces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">aeroforces(model::AeroModel, atm::AtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the aerodynamic forces and moments in the body frame. return F, M</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL136-L141">source</a></section><p>The default implementation of <code>AeroModel</code> is one based on stability derivatives.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.StabilityDeriv" href="#SixDOF.StabilityDeriv"><code>SixDOF.StabilityDeriv</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StabilityDeriv(CL0, CLalpha, CLq, CLM, CLdf, CLde, alphas, 
    CD0, U0, exp_Re, e, Mcc, CDdf, CDde, CDda, CDdr, 
    CYbeta, CYp, CYr, CYda, CYdr, Clbeta, 
    Clp, Clr, Clda, Cldr, 
    Cm0, Cmalpha, Cmq, CmM, Cmdf, Cmde, 
    Cnbeta, Cnp, Cnr, Cnda, Cndr)</code></pre><p>Stability derivatives of the aircraft.  Most are self explanatory if you are familiar with stability derivatives (e.g., CLalpha is dCL/dalpha or the lift curve slope). Some less familiar ones include</p><ul><li>M: Mach number</li><li>alphas: the angle of attack for stall</li><li>U0: the speed for the reference Reynolds number CD0 was computed at</li><li>exp_Re: the coefficient in the denominator of the skin friction coefficient (0.5 laminar, 0.2 turbulent)</li><li>e: Oswald efficiency factor</li><li>Mcc: crest critical Mach number (when compressibility drag rise starts)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL275-L293">source</a></section><p>We use the following values for this example.</p><pre><code class="language-julia">CL0 = 0.09167 # Zero-alpha lift
CLalpha = 3.5016  # lift curve slope
CLq = 2.8932 # Pitch rate derivative
CLM = 0.0 # Mach derivative
CLdf = 0.0  # flaps derivative
CLde = 0.2724  # elevator derivative
CLmax = 1.4  # max CL (stall)
CLmin = -0.9  # min CL (neg stall)
alphas = 20*pi/180

CD0 = 0.01631  # zero-lift drag coerff
U0 = 10.0  # velocity corresponding to Reynolds number of CD0
exp_Re = -0.2  # exponent in Reynolds number calc
e = 0.8  # Oswald efficiency
Mcc = 0.7  # crest critcal Mach number
CDdf = 0.0  # flaps
CDde = 0.3045  # elevator
CDda = 0.0  # aileron
CDdr = 0.0  # rudder

CYbeta = -0.07359 # Sideslip derivative
CYp = 0.0  # Roll rate derivative
CYr = 0.0 # Yaw rate derivative
CYda = 0.0 # Roll control (aileron) derivative
CYdr = 0.0 # Yaw control (rudder) derivative

Clbeta = -0.02854  # Sideslip derivative
Clp = -0.3209  # Roll rate derivative
Clr = 0.03066  # Yaw rate derivative
Clda = 0.1682  # Roll (aileron) control derivative
Cldr = 0.0  #Yaw (rudder) control derivative

Cm0 = -0.02338 # Zero-alpha pitch
Cmalpha = -0.5675 # Alpha derivative
Cmq = -1.3990 # Pitch rate derivative
CmM = 0.0
Cmdf = 0.0
Cmde = -0.3254 # Pitch control derivative

Cnbeta = -0.00040  # Slideslip derivative
Cnp = -0.01297  # Roll rate derivative
Cnr = -0.00434  # Yaw rate derivative
Cnda = -0.00328  # Roll (aileron) control derivative
Cndr = 0.0  # Yaw (rudder) control derivative

sd = StabilityDeriv(CL0, CLalpha, CLq, CLM, CLdf, CLde, alphas,
    CD0, U0, exp_Re, e, Mcc, CDdf, CDde, CDda, CDdr,
    CYbeta, CYp, CYr, CYda, CYdr,
    Clbeta, Clp, Clr, Clda, Cldr,
    Cm0, Cmalpha, Cmq, CmM, Cmdf, Cmde,
    Cnbeta, Cnp, Cnr, Cnda, Cndr)</code></pre><p>The <code>PropulsionModel</code> abstract type must define the following function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.propulsionforces-Tuple{PropulsionModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}" href="#SixDOF.propulsionforces-Tuple{PropulsionModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}"><code>SixDOF.propulsionforces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propulsionforces(model::PropulsionModel, atm::AtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the propulsive forces and moments in the body frame. return F, M</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL154-L159">source</a></section><p>The default implementation of <code>PropulsionModel</code> is based on a first-order motor model coupled with a parameterized curve fit of propeller data.  The torque for when the motor and propeller are matched is solved for and then used to compute thrust.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.MotorPropBatteryDataFit" href="#SixDOF.MotorPropBatteryDataFit"><code>SixDOF.MotorPropBatteryDataFit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MotorPropBatteryDataFit(CT2, CT1, CT0, CQ2, CQ1, CQ0, D, num, type,
    R, Kv, i0, voltage)</code></pre><p><strong>Inputs</strong></p><ul><li>CT2, CT1, CT0: quadratic fit to propeller thrust coefficient of form: CT = CT2<em>J2 + CT1</em>J + CT0</li><li>CQ2, CQ1, CQ0: quadratic fit to propeller torque coefficient of form: CQ = CQ2<em>J2 + CQ1</em>J + CQ0</li><li>D: propeller diameter</li><li>num: number of propellers</li><li>type: CO (torques add), COUNTER (torques add but with minus sign), COCOUNTER (no torque, they cancel out)</li><li>R: motor resistance</li><li>Kv: motor Kv</li><li>i0: motor no-load current</li><li>voltage: battery voltage</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL403-L417">source</a></section><p>This example uses data roughly corresponding to an APC thin electric 10x5</p><pre><code class="language-julia">CT0 = 0.11221
CT1 = -0.13803
CT2 = -0.047394
CQ0 = 0.0062
CQ1 = 0.00314
CQ2 = -0.015729
D = 10*0.0254
num = 2
type = COCOUNTER
R = 0.5
Kv = 2500.0 * pi/30
i0 = 0.3
voltage = 8.0
propulsion = MotorPropBatteryDataFit(CT2, CT1, CT0, CQ2, CQ1, CQ0, D, num, type, R, Kv, i0, voltage)</code></pre><p>Finally, the <code>InertialModel</code> must implment the following function</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.gravityforces-Tuple{InertialModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}" href="#SixDOF.gravityforces-Tuple{InertialModel,AtmosphereModel,SixDOF.State,Control,MassProp,Reference}"><code>SixDOF.gravityforces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gravityforces(model::InertialModel, atm::AtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the gravitational forces and moments in the body frame. return F, M</p></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL172-L177">source</a></section><p>The default implementation (<span>$UniformGravitationalField$</span>) assumes that the center of mass and center of gravity are coincident and so there is no gravitational moment.  The default will likely be used most of the time as that condition is true for almost all applications, except perhaps some spacecraft in high orbits where small gravitational torques may matter.</p><pre><code class="language-julia">inertial = UniformGravitationalField()</code></pre><p>The main function is </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SixDOF.sixdof!" href="#SixDOF.sixdof!"><code>SixDOF.sixdof!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sixdof!(ds, s, params, time)</code></pre><p>dynamic and kinematic ODEs.  Follows format used in DifferentialEquations package.</p><ul><li>s = x, y, z, phi, theta, psi, u, v, w, p, q, r (same order as State)</li><li>params = control, massproperties, reference, aeromodel, propmodel, inertialmodel, atmmodel</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/37549cb364fd773b7395dd1eefdb8ef988c9a45e/src/SixDOF.jl#LL514-L520">source</a></section><p>We rarely use it directly, but rather use it in connection with an ODE solver.  In this case the <span>$DifferentialEquations$</span> package.  We start with an initial velocity at an angle of attack and simulate for four seconds.</p><pre><code class="language-julia">import DifferentialEquations

Vinf = U0
alpha = 3.0*pi/180
s0 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Vinf*cos(alpha), 0.0, Vinf*sin(alpha), 0.0, 0.0, 0.0]
tspan = (0.0, 4.0)
p = control, mp, ref, sd, propulsion, inertial, atm


prob = DifferentialEquations.ODEProblem(sixdof!, s0, tspan, p)
sol = DifferentialEquations.solve(prob)</code></pre><p>We can plot the results.  For example the linear positions and velocities.  The y-components are not plotted in this case, because they are all zero as there are no control deflections or wind that would cause lateral motion in this example.</p><pre><code class="language-julia">using PyPlot

figure()
plot(sol.t, sol[1, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;x inertial position (m)&quot;)
figure()
plot(sol.t, sol[3, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;z inertial position (m)&quot;)
figure()
plot(sol.t, sol[7, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;u body velocity (m/s)&quot;)
figure()
figure()
plot(sol.t, sol[9, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;w body velocity (m/s)&quot;)</code></pre><p><img src="../x.svg" alt/> <img src="../z.svg" alt/> <img src="../u.svg" alt/> <img src="../w.svg" alt/></p><footer><hr/><a class="next" href="../theory/"><span class="direction">Next</span><span class="title">Theory</span></a></footer></article></body></html>
