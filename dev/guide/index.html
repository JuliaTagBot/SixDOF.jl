<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · SixDOF.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SixDOF.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Additional-Helper-Functions-1"><span>Additional Helper Functions</span></a></li></ul></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/SixDOF.jl/blob/master/docs/src/guide.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide-1"><a class="docs-heading-anchor" href="#Guide-1">Guide</a><a class="docs-heading-anchor-permalink" href="#Guide-1" title="Permalink"></a></h1><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>First, we import the module.</p><pre><code class="language-julia">using SixDOF</code></pre><p>There are several structs we need to define.  The inputs used in this example correspond to the Zagi flying wing in Appendix E of Small Unmanned Aircraft: Theory and Practice by Beard and McLain.  We specify the mass properties:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.MassProp" href="#SixDOF.MassProp"><code>SixDOF.MassProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MassProp(m, Ixx, Iyy, Izz, Ixz, Ixy, Iyz)</code></pre><p>Mass and moments of inertia in the body frame. Ixx = int(y^2 + z^2, dm) Ixz = int(xz, dm)</p><p>Most aircraft are symmetric about y and so there is a convenience method  to specify only the nonzero components. MassProp(m, Ixx, Iyy, Izz, Ixz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL51-L61">source</a></section></article><p>For this example:</p><pre><code class="language-julia">m = 1.56
Ixx = 0.1147
Iyy = 0.0576
Izz = 0.1712
Ixz = 0.0015
mp = MassProp(m, Ixx, Iyy, Izz, Ixz)</code></pre><p>Next, we specify reference areas and lengths:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.Reference" href="#SixDOF.Reference"><code>SixDOF.Reference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Reference(S, b, c)</code></pre><p>The reference area, span, and chord used in the aerodynamic computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL76-L80">source</a></section></article><pre><code class="language-julia">Sref = 0.2589
bref = 1.4224
cref = 0.3302
ref = Reference(Sref, bref, cref)</code></pre><p>A controller builds off the abstract type <code>AbstractController</code>, which must supply the following method:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.setcontrol" href="#SixDOF.setcontrol"><code>SixDOF.setcontrol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setcontrol(controller::AbstractController, time, atm::AbstractAtmosphereModel, state::State, lastcontrol::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute control state for next time step given current state   return control::Control</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL193-L198">source</a></section></article><p>There is a default implementation in the module, which is just a dummy controller that outputs contant control output</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.ConstantController" href="#SixDOF.ConstantController"><code>SixDOF.ConstantController</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantController(de, dr, da, df, throttle)</code></pre><p>Just a dummy controller that outputs constant control outputs the whole time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL563-L567">source</a></section></article><p>In this example, we don&#39;t use any control deflections.  Just throttle, at 80%.</p><pre><code class="language-julia">controller = ConstantController(0.0, 0.0, 0.0, 0.0, 0.8)</code></pre><p>Next, we define the atmospheric model.  <code>AbstractAtmosphereModel</code> is an abstract type that must define the following three methods.</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.wind-Tuple{AbstractAtmosphereModel,Any}" href="#SixDOF.wind-Tuple{AbstractAtmosphereModel,Any}"><code>SixDOF.wind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wind(model::AbstractAtmosphereModel, state)</code></pre><p>Compute wind velocities.</p><p><strong>Returns</strong></p><ul><li>Wi: wind velocities in inertial frame</li><li>Wb: gust velocities in body frame (just a convenience to allow some velocities in body frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL94-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SixDOF.properties-Tuple{AbstractAtmosphereModel,Any}" href="#SixDOF.properties-Tuple{AbstractAtmosphereModel,Any}"><code>SixDOF.properties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">properties(model::AbstractAtmosphereModel, state)</code></pre><p>Compute atmospheric density and the speed of sound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SixDOF.gravity" href="#SixDOF.gravity"><code>SixDOF.gravity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gravity(model::AbstractAtmosphereModel, state)</code></pre><p>Compute the local acceleration of gravity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL122-L126">source</a></section></article><p>There is a default implementation in the module, which is the simplest possible model: one with constant properties:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.ConstantAtmosphere" href="#SixDOF.ConstantAtmosphere"><code>SixDOF.ConstantAtmosphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantAtmosphere(Wi, Wb, rho, asound, g)</code></pre><p>Constant atmospheric properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL536-L540">source</a></section></article><p>We use that in this example:</p><pre><code class="language-julia">Wi = [0.0, 0.0, 0.0]
Wb = [0.0, 0.0, 0.0]
rho = 1.2682
asound = 300.0
g = 9.81
atm = ConstantAtmosphere(Wi, Wb, rho, asound, g)</code></pre><p>Finally, we now need to define the forces and moments.  We provide three abstract types for three types of forces: aerodynamics, propulsion, and gravity.  In principle you could use these methods to define forces/moments for any application, but for aircraft this is a convenient separation.</p><p>All three forces take in all the same inputs, which include everything discussed so far and the state.  The state is an internally used struct that contains the state of the aircraft (or other object).</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.State" href="#SixDOF.State"><code>SixDOF.State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">State(x, y, z, phi, theta, psi, u, v, w, p, q, r)</code></pre><p>State of the aircraft: positions in inertial frame, euler angles, velocities in body frame, angular velocities in body frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL16-L21">source</a></section></article><p>The <code>AbstractAeroModel</code> abstract type must define the following function:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.aeroforces-Tuple{AbstractAeroModel,Any,Any,Any,Any,Any}" href="#SixDOF.aeroforces-Tuple{AbstractAeroModel,Any,Any,Any,Any,Any}"><code>SixDOF.aeroforces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aeroforces(model::AbstractAeroModel, atm::AbstractAtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the aerodynamic forces and moments in the body frame. return F, M</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL138-L143">source</a></section></article><p>The default implementation of <code>AbstractAeroModel</code> is one based on stability derivatives.</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.StabilityDeriv" href="#SixDOF.StabilityDeriv"><code>SixDOF.StabilityDeriv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StabilityDeriv(CL0, CLalpha, CLq, CLM, CLdf, CLde, alphas, 
    CD0, U0, exp_Re, e, Mcc, CDdf, CDde, CDda, CDdr, 
    CYbeta, CYp, CYr, CYda, CYdr, Clbeta, 
    Clp, Clr, Clda, Cldr, 
    Cm0, Cmalpha, Cmq, CmM, Cmdf, Cmde, 
    Cnbeta, Cnp, Cnr, Cnda, Cndr)</code></pre><p>Stability derivatives of the aircraft.  Most are self explanatory if you are familiar with stability derivatives (e.g., CLalpha is dCL/dalpha or the lift curve slope). Some less familiar ones include</p><ul><li>M: Mach number</li><li>alphas: the angle of attack for stall</li><li>U0: the speed for the reference Reynolds number CD0 was computed at</li><li>exp_Re: the coefficient in the denominator of the skin friction coefficient (0.5 laminar, 0.2 turbulent)</li><li>e: Oswald efficiency factor</li><li>Mcc: crest critical Mach number (when compressibility drag rise starts)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL323-L341">source</a></section></article><p>We use the following values for this example.</p><pre><code class="language-julia">CL0 = 0.09167 # Zero-alpha lift
CLalpha = 3.5016  # lift curve slope
CLq = 2.8932 # Pitch rate derivative
CLM = 0.0 # Mach derivative
CLdf = 0.0  # flaps derivative
CLde = 0.2724  # elevator derivative
CLmax = 1.4  # max CL (stall)
CLmin = -0.9  # min CL (neg stall)
alphas = 20*pi/180

CD0 = 0.01631  # zero-lift drag coerff
U0 = 10.0  # velocity corresponding to Reynolds number of CD0
exp_Re = -0.2  # exponent in Reynolds number calc
e = 0.8  # Oswald efficiency
Mcc = 0.7  # crest critcal Mach number
CDdf = 0.0  # flaps
CDde = 0.3045  # elevator
CDda = 0.0  # aileron
CDdr = 0.0  # rudder

CYbeta = -0.07359 # Sideslip derivative
CYp = 0.0  # Roll rate derivative
CYr = 0.0 # Yaw rate derivative
CYda = 0.0 # Roll control (aileron) derivative
CYdr = 0.0 # Yaw control (rudder) derivative

Clbeta = -0.02854  # Sideslip derivative
Clp = -0.3209  # Roll rate derivative
Clr = 0.03066  # Yaw rate derivative
Clda = 0.1682  # Roll (aileron) control derivative
Cldr = 0.0  #Yaw (rudder) control derivative

Cm0 = -0.02338 # Zero-alpha pitch
Cmalpha = -0.5675 # Alpha derivative
Cmq = -1.3990 # Pitch rate derivative
CmM = 0.0
Cmdf = 0.0
Cmde = -0.3254 # Pitch control derivative

Cnbeta = -0.00040  # Slideslip derivative
Cnp = -0.01297  # Roll rate derivative
Cnr = -0.00434  # Yaw rate derivative
Cnda = -0.00328  # Roll (aileron) control derivative
Cndr = 0.0  # Yaw (rudder) control derivative

sd = StabilityDeriv(CL0, CLalpha, CLq, CLM, CLdf, CLde, alphas,
    CD0, U0, exp_Re, e, Mcc, CDdf, CDde, CDda, CDdr,
    CYbeta, CYp, CYr, CYda, CYdr,
    Clbeta, Clp, Clr, Clda, Cldr,
    Cm0, Cmalpha, Cmq, CmM, Cmdf, Cmde,
    Cnbeta, Cnp, Cnr, Cnda, Cndr)</code></pre><p>The <code>AbstractPropulsionModel</code> abstract type must define the following function:</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.propulsionforces-Tuple{AbstractPropulsionModel,Any,Any,Any,Any,Any}" href="#SixDOF.propulsionforces-Tuple{AbstractPropulsionModel,Any,Any,Any,Any,Any}"><code>SixDOF.propulsionforces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propulsionforces(model::AbstractPropulsionModel, atm::AbstractAtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the propulsive forces and moments in the body frame. return F, M</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL156-L161">source</a></section></article><p>The default implementation of <code>AbstractPropulsionModel</code> is based on a first-order motor model coupled with a parameterized curve fit of propeller data.  The torque for when the motor and propeller are matched is solved for and then used to compute thrust.</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.MotorPropBatteryDataFit" href="#SixDOF.MotorPropBatteryDataFit"><code>SixDOF.MotorPropBatteryDataFit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MotorPropBatteryDataFit(CT2, CT1, CT0, CQ2, CQ1, CQ0, D, num, type,
    R, Kv, i0, voltage)</code></pre><p><strong>Inputs</strong></p><ul><li>CT2, CT1, CT0: quadratic fit to propeller thrust coefficient of form: CT = CT2<em>J2 + CT1</em>J + CT0</li><li>CQ2, CQ1, CQ0: quadratic fit to propeller torque coefficient of form: CQ = CQ2<em>J2 + CQ1</em>J + CQ0</li><li>D: propeller diameter</li><li>num: number of propellers</li><li>type: CO (torques add), COUNTER (torques add but with minus sign), COCOUNTER (no torque, they cancel out)</li><li>R: motor resistance</li><li>Kv: motor Kv</li><li>i0: motor no-load current</li><li>voltage: battery voltage</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL451-L465">source</a></section></article><p>This example uses data roughly corresponding to an APC thin electric 10x5</p><pre><code class="language-julia">CT0 = 0.11221
CT1 = -0.13803
CT2 = -0.047394
CQ0 = 0.0062
CQ1 = 0.00314
CQ2 = -0.015729
D = 10*0.0254
num = 2
type = COCOUNTER
R = 0.5
Kv = 2500.0 * pi/30
i0 = 0.3
voltage = 8.0
propulsion = MotorPropBatteryDataFit(CT2, CT1, CT0, CQ2, CQ1, CQ0, D, num, type, R, Kv, i0, voltage)</code></pre><p>Finally, the <code>AbstractInertialModel</code> must implment the following function</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.gravityforces-Tuple{AbstractInertialModel,Any,Any,Any,Any,Any}" href="#SixDOF.gravityforces-Tuple{AbstractInertialModel,Any,Any,Any,Any,Any}"><code>SixDOF.gravityforces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gravityforces(model::AbstractInertialModel, atm::AbstractAtmosphereModel, state::State, control::Control, mp::MassProp, ref::Reference)</code></pre><p>Compute the gravitational forces and moments in the body frame. return F, M</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL174-L179">source</a></section></article><p>The default implementation (<span>$UniformGravitationalField$</span>) assumes that the center of mass and center of gravity are coincident and so there is no gravitational moment.  The default will likely be used most of the time as that condition is true for almost all applications, except perhaps some spacecraft in high orbits where small gravitational torques may matter.</p><pre><code class="language-julia">inertial = UniformGravitationalField()</code></pre><p>The main function is </p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.sixdof!" href="#SixDOF.sixdof!"><code>SixDOF.sixdof!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sixdof!(ds, s, params, time)</code></pre><p>dynamic and kinematic ODEs.  Follows format used in DifferentialEquations package.</p><ul><li>s = x, y, z, phi, theta, psi, u, v, w, p, q, r (same order as State)</li><li>params = control, massproperties, reference, aeromodel, propmodel, inertialmodel, atmmodel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL584-L590">source</a></section></article><p>We rarely use it directly, but rather use it in connection with an ODE solver.  In this case the <span>$DifferentialEquations$</span> package.  We start with an initial velocity at an angle of attack and simulate for four seconds.</p><pre><code class="language-julia">import DifferentialEquations

Vinf = U0
alpha = 3.0*pi/180
s0 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Vinf*cos(alpha), 0.0, Vinf*sin(alpha), 0.0, 0.0, 0.0]
tspan = (0.0, 4.0)
p = mp, ref, sd, propulsion, inertial, atm, controller


prob = DifferentialEquations.ODEProblem(sixdof!, s0, tspan, p)
sol = DifferentialEquations.solve(prob)</code></pre><pre><code class="language-none">WARNING: Method definition vec(Number) in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114 overwritten in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **

WARNING: Method definition vec(Number) in module DiffEqDiffTools at /home/runner/.julia/packages/DiffEqDiffTools/3mm8U/src/jacobians.jl:114 overwritten in module FiniteDiff at /home/runner/.julia/packages/FiniteDiff/zeWoZ/src/jacobians.jl:114.
  ** incremental compilation may be fatally broken for this module **</code></pre><p>We can plot the results.  For example the linear positions and velocities.  The y-components are not plotted in this case, because they are all zero as there are no control deflections or wind that would cause lateral motion in this example.</p><pre><code class="language-julia">using PyPlot

figure()
plot(sol.t, sol[1, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;x inertial position (m)&quot;)
figure()
plot(sol.t, sol[3, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;z inertial position (m)&quot;)
figure()
plot(sol.t, sol[7, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;u body velocity (m/s)&quot;)
figure()
figure()
plot(sol.t, sol[9, :])
xlabel(&quot;time (s)&quot;)
ylabel(&quot;w body velocity (m/s)&quot;)</code></pre><p><img src="../x.svg" alt/> <img src="../z.svg" alt/> <img src="../u.svg" alt/> <img src="../w.svg" alt/></p><h2 id="Additional-Helper-Functions-1"><a class="docs-heading-anchor" href="#Additional-Helper-Functions-1">Additional Helper Functions</a><a class="docs-heading-anchor-permalink" href="#Additional-Helper-Functions-1" title="Permalink"></a></h2><p>A few other helper functions exist.  These first three create rotation matrices from one coordinate system to the body frame.  All of these rotation matrices are orthogonal so the inverse of the matrix is just its transpose.</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.inertialtobody" href="#SixDOF.inertialtobody"><code>SixDOF.inertialtobody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inertialtobody(state)</code></pre><p>Construct a rotation matrix from inertial frame to body frame</p><p>The assumed order of rotation is </p><ol><li>psi radians about the z axis, </li><li>theta radians about the y axis, </li><li>phi radians about the x axis. </li></ol><p>This is an orthogonal transformation so its inverse is its transpose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL214-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SixDOF.windtobody" href="#SixDOF.windtobody"><code>SixDOF.windtobody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">windtobody(alpha, beta)</code></pre><p>Rotation matrix from wind frame to body frame.</p><ul><li>alpha: angle of attack</li><li>beta: sideslip angle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SixDOF.stabilitytobody" href="#SixDOF.stabilitytobody"><code>SixDOF.stabilitytobody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stabilitytobody(alpha, beta)</code></pre><p>Rotation matrix from stability frame to body frame.</p><ul><li>alpha: angle of attack</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL269-L274">source</a></section></article><p>Another function extracts airspeed, angle of attack, and sideslip from the body motion and wind.</p><article class="docstring"><header><a class="docstring-binding" id="SixDOF.windaxes" href="#SixDOF.windaxes"><code>SixDOF.windaxes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">windaxes(atm::AbstractAtmosphereModel, state)</code></pre><p>Compute relative velocity in wind axes (airspeed, aoa, sideslip)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/SixDOF.jl/blob/7611c300d0fba2164a95e160d175b4d0d09ae644/src/SixDOF.jl#LL288-L292">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../theory/">Theory »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 January 2020 23:19">Thursday 23 January 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
